<?php

declare(strict_types=1);

namespace Kanti\JsonToClass\Code;

use Exception;
use Kanti\JsonToClass\Dto\FullyQualifiedClassName;
use Kanti\JsonToClass\Schema\PropertyType;
use Kanti\JsonToClass\Schema\SchemaElement;
use Kanti\JsonToClass\Transformer\Transformer;
use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\Method;
use Nette\PhpGenerator\Parameter;
use Nette\PhpGenerator\PhpFile;
use Nette\PhpGenerator\PhpNamespace;
use Nette\PhpGenerator\Printer;
use Nette\PhpGenerator\PsrPrinter;

final readonly class CodeGenerator
{
    public function __construct(private Printer $printer = new PsrPrinter())
    {
    }

    public function fromSchema(FullyQualifiedClassName $class, SchemaElement $schemaElement): Classes
    {
        if ($schemaElement->listElement) {
            return $this->fromSchema($class, $schemaElement->listElement);
        }

        if ($schemaElement->basicTypes) {
            throw new Exception('Basic types not supported at this level ' . json_encode($schemaElement));
        }

        $classes = new Classes();

        $file = new PhpFile();
        $file->addComment('declare(strict_types=1); missing by design');
        $file->addComment('This file is generated by kanti/json-to-class');

        $namespace = $file->addNamespace($class->namespace);
        $classType = $namespace
            ->addClass($class->className)
            ->setFinal()
            ->setReadOnly();
        $constructor = $classType
            ->addMethod('__construct')
            ->setPublic();

        $properties = [];

        foreach ($schemaElement->getProperties() as $property => $childElement) {
            $childClass = new FullyQualifiedClassName($class . '\\' . ucfirst($property));

            $type = $childElement->getTypeName($childClass);
            $properties[$property] = $type;

            $simplifiedName = $type->type;
            if ($type->isClass) {
                $namespace->addUse($type->type);
                $simplifiedName = $namespace->simplifyName($simplifiedName);
            }


            if ($childElement->listElement) {
                $constructor->addComment('@param ' . $type->getDocBlockType($simplifiedName) . ' $' . $property);

                $promotedParameter = $constructor
                    ->addPromotedParameter($property)
                    ->setType('array');

                if ($childElement->canBeMissing) {
                    $promotedParameter->setDefaultValue([]);
                }

                if (!$childElement->listElement->basicTypes) {
                    $classes->add($this->fromSchema($childClass, $childElement->listElement));
                }

                continue;
            }

            if ($childElement->isEmpty()) {
                $constructor->addComment('@param array{} $' . $property);
                $promotedParameter = $constructor
                    ->addPromotedParameter($property)
                    ->setType('array');

                if ($childElement->canBeMissing) {
                    $promotedParameter->setDefaultValue([]);
                }

                continue;
            }

            $promotedParameter = $constructor
                ->addPromotedParameter($property)
                ->setType($type->type);

            if ($childElement->canBeMissing) {
                $promotedParameter->setDefaultValue(null);
                if (!str_contains((string) $promotedParameter->getType(), 'null')) {
                    $promotedParameter->setNullable();
                }
            }

            if ($childElement->properties) {
                $classes->add($this->fromSchema($childClass, $childElement));
            }
        }

        $this->orderParameters($constructor);
        $this->addFromMethod($namespace, $classType, $properties);

        $classes->addClass($class, $this->printer->printFile($file));
        return $classes;
    }

    private function orderParameters(Method $constructor): void
    {
        $parameters = $constructor->getParameters();
        /** @var list<Parameter> $parameterWithoutDefault */
        $parameterWithoutDefault = [];
        /** @var list<Parameter> $parameterWithDefault */
        $parameterWithDefault = [];
        foreach ($parameters as $parameter) {
            if ($parameter->hasDefaultValue()) {
                $parameterWithDefault[] = $parameter;
                continue;
            }

            $parameterWithoutDefault[] = $parameter;
        }

        $constructor->setParameters([...$parameterWithoutDefault, ...$parameterWithDefault]);
    }

    /**
     * @param array<string, PropertyType> $properties
     */
    private function addFromMethod(PhpNamespace $namespace, ClassType $classType, array $properties): void
    {
        $method = $classType
            ->addMethod('from')
            ->setStatic()
            ->setReturnType('self')
            ->setComment('@param array<string, mixed> $data');
        $method
            ->addParameter('data')
            ->setType('array');

        $namespace->addUse(Transformer::class);
        $method
            ->addParameter('transformer')
            ->setType(Transformer::class);

        $array = [];
        foreach ($properties as $name => $property) {
            if (!$property->isClass) {
                $array[] = "->native('" . $name . "')";
                continue;
            }

            $namespace->addUse($property->type);
            $depthPart = '';
            if ($property->listDepth) {
                $depthPart = ', ' . $property->listDepth;
            }

            $array[] = "->class('" . $name . "', " . $namespace->simplifyName($property->type) . '::class' . $depthPart . ')';
        }

        $body = '';
        $body .= 'return new self(' . PHP_EOL;
        $body .= '    ...$transformer' . PHP_EOL;
        $body .= '    ->for($data)' . PHP_EOL;
        foreach ($array as $item) {
            $body .= '    ' . $item . PHP_EOL;
        }

        $body .= ');';
        $method->setBody($body);
    }
}
